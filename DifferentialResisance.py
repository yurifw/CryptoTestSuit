#!/usr/bin/python


input_legth = 8  # input length of the S-Box in bits
output_length = 8  # output length of the S-Box  in bits

#function implementing an sbox, inp should be an input (plaintext), and it should return the result of passing it through the sbox
def SBOX(inp):
    s_box = 	((0x63 , 0x7c , 0x7b , 0x77 , 0x6f , 0xc5 , 0x6b , 0xf2 , 0xfe , 0xd7 , 0x76 , 0xab , 0x67 , 0x2b , 0x01 , 0x30 ),
		(0xad , 0xd4 , 0xaf , 0xa2 , 0x72 , 0xc0 , 0xa4 , 0x9c , 0xfa , 0x59 , 0xf0 , 0x47 , 0xc9 , 0x7d , 0x82 , 0xca ),
		(0x04 , 0xc7 , 0xc3 , 0x23 , 0x05 , 0x9a , 0x96 , 0x18 , 0xeb , 0x27 , 0x75 , 0xb2 , 0x80 , 0xe2 , 0x12 , 0x07 ),
		(0x34 , 0xa5 , 0xf1 , 0xe5 , 0x31 , 0x15 , 0xd8 , 0x71 , 0x36 , 0x3f , 0xcc , 0xf7 , 0x93 , 0x26 , 0xfd , 0xb7 ),
		(0xd0 , 0xef , 0xfb , 0xaa , 0x33 , 0x85 , 0x4d , 0x43 , 0x50 , 0x3c , 0xa8 , 0x9f , 0x02 , 0x7f , 0xf9 , 0x45 ),
		(0xbc , 0xb6 , 0x21 , 0xda , 0xf3 , 0xd2 , 0xff , 0x10 , 0x92 , 0x9d , 0xf5 , 0x38 , 0x40 , 0x8f , 0xa3 , 0x51 ),
		(0x53 , 0xd1 , 0xed , 0x00 , 0xb1 , 0x5b , 0xfc , 0x20 , 0x4a , 0x4c , 0xcf , 0x58 , 0xbe , 0x39 , 0xcb , 0x6a ),
		(0x52 , 0x3b , 0xb3 , 0xd6 , 0x2f , 0x84 , 0xe3 , 0x29 , 0x1b , 0x6e , 0xa0 , 0x5a , 0x2c , 0x1a , 0x83 , 0x09 ),
		(0xba , 0x78 , 0x2e , 0x25 , 0xb4 , 0xc6 , 0xa6 , 0x1c , 0x4b , 0xbd , 0x8a , 0x8b , 0x74 , 0x1f , 0xdd , 0xe8 ),
		(0x61 , 0x35 , 0xb9 , 0x57 , 0x1d , 0x9e , 0xc1 , 0x86 , 0x48 , 0x03 , 0x0e , 0xf6 , 0xb5 , 0x66 , 0x3e , 0x70 ),
		(0x8c , 0xa1 , 0x0d , 0x89 , 0x42 , 0x68 , 0xe6 , 0xbf , 0xb0 , 0x54 , 0x16 , 0xbb , 0x2d , 0x0f , 0x99 , 0x41 ),
		(0x9b , 0x1e , 0xe9 , 0x87 , 0x28 , 0xdf , 0x55 , 0xce , 0x69 , 0xd9 , 0x94 , 0x8e , 0x98 , 0x11 , 0xf8 , 0xe1 ),
		(0xe0 , 0x32 , 0x0a , 0x3a , 0x24 , 0x5c , 0x06 , 0x49 , 0x91 , 0x95 , 0x79 , 0xe4 , 0xac , 0x62 , 0xd3 , 0xc2 ),
		(0x6c , 0x56 , 0xea , 0xf4 , 0xae , 0x08 , 0x7a , 0x65 , 0x8d , 0xd5 , 0xa9 , 0x4e , 0x37 , 0x6d , 0xc8 , 0xe7 ),
		(0x60 , 0x81 , 0xdc , 0x4f , 0x90 , 0x88 , 0x2a , 0x22 , 0xde , 0x5e , 0xdb , 0x0b , 0xb8 , 0x14 , 0xee , 0x46 ),
		(0xc4 , 0xa7 , 0x3d , 0x7e , 0x19 , 0x73 , 0x5d , 0x64 , 0x5f , 0x97 , 0x17 , 0x44 , 0x13 , 0xec , 0x0c , 0xcd ))
    col = inp >> 4
    row = inp & 15
    return s_box[col][row]



#generates the xor distribution table
def generate_table():
    table = [[0 for x in range(pow(2,input_legth))] for x in range(pow(2,output_length))];  # the table, In is the XOR of the in-going pair, Out is the resulting XOR, the table returns the number of occurences

    c2 = [0]*pow(2,input_legth)  # holds the results of the plain texts for later use
    for p2 in range(pow(2,input_legth)):
        c2[p2]=SBOX(p2)

    for p1 in range(pow(2,input_legth)):
        c1=SBOX(p1)
        for p2 in range(pow(2,input_legth)):
            xor_in = p1 ^ p2
            xor_out = c1 ^ c2[p2]
            table[xor_in][xor_out] += 1
    return table


#only works with nxn sboxes
def calculate_robustness_to_differential_cryptanalysis(xor_distribution_table):
    def r(N, n, l):
        N = float(N)
        n = float(n)
        l = float(l)
        return (1-N/pow(2,n))*(1-l/pow(2,n))

    N=0
    l=0
    for lin in range(pow(2,input_legth)):
        for col in range(pow(2,input_legth)):
            if col == 0 and xor_distribution_table[lin][col]!=0:
                N +=1
            if xor_distribution_table[lin][col] > l and lin !=0 and col != 0 :
                l = xor_distribution_table[lin][col]
    #print N
    #print input_legth
    #print l
    return r(N, input_legth, l)

print calculate_robustness_to_differential_cryptanalysis(generate_table())
#print hex(SBOX(0x58))

